#!/usr/bin/ruby
$stdout.sync = true

require 'beaneater'
require 'json'
require 'optparse'
require 'yaml'

$options = {}
$options[:server]="localhost:11300"
$options[:control]="mux-control"
$options[:expiry]=3600
$options[:debug]=false
$options[:saveonexit]=false

# retry so many times to deliver the job to the consumers
$options[:retries]=100

# put a job back into the queue after n seconds, when no consumers are registered
$options[:release_delay]=30

opts = OptionParser.new do |opts|
	opts.banner = "Usage: beanstalk-multiplex [options]"
	opts.on('-h', '--host HOST:PORT', 'beanstalk server to connect to (defaults to localhost:11300)') { |v| $options[:server] = v }
	opts.on('-s', '--sourcetube NAME', 'source tube name') { |v| $options[:source] = v }
	opts.on('-c', '--controltube NAME', 'control tube name (defaults to "mux-control")') { |v| $options[:control] = v }
	opts.on('-e', '--expiry seconds', Float, 'time to live for target tubes (defaults to 3600)') { |v| $options[:expiry] = v }
	opts.on('-d', '--debug', 'spit out debug infos') { |v| $options[:debug] = v }
	opts.on('-e', '--saveonexit', 'save the current tubes to control tube on exit') { |v| $options[:saveonexit] = v }
end

opts.parse!

if $options[:source]==nil
	puts "Fatal: No source tube given"
	exit 1
end

# hash of tube-name and expiry point in time
$tubes2put = {}

class NoTubesError < StandardError
end

beanpool = Beaneater::Pool.new([$options[:server]])

def processControlJob(job)
	$tubes2put[job.body.to_s]=Time.now+$options[:expiry]
	puts "keep-alive extended for '#{job.body}' (#{$tubes2put[job.body.to_s]})" if $options[:debug]
end

control = beanpool.tubes[$options[:control]]
while control.peek(:ready)
	job = control.reserve
	processControlJob(job)
	job.delete
end

beanpool.jobs.register($options[:source], :retry_on => [NoTubesError], :retries => 10) do |job|
	puts "job taken from source tube" if $options[:debug]
	$tubes2put.each do |tubename, expiry|
		if expiry>Time.now
			puts "-> #{tubename}" if $options[:debug]
			beanpool.tubes[tubename].put(job.body)
		else
			$tubes2put.delete tubename
			puts "expired #{tubename}" if $options[:debug]
		end
	end
	if $tubes2put.length==0
		puts "no target tubes found - putting job back to tube with 20s delay" 
		raise NoTubesError
	end
end

beanpool.jobs.register($options[:control]) do |job|
	processControlJob(job)
end
	
processor = Thread.new do
	puts "Starting to process jobs" if $options[:debug]
	beanpool.jobs.process! :release_delay => $options[:release_delay]
	beanpool2.close
	puts "Finished processing" if $options[:debug]
end

%w(INT USR1 USR2 TERM TTIN).each do |sig|
	trap sig do
		Thread.kill(processor)
	end
end

processor.join

# use a new connection to the server as the old one may still block
#  if there was no traffic on the tubes.
beanpool2 = Beaneater::Pool.new([$options[:server]])
if $options[:saveonexit]
	puts "Saving current tubes to #{$options[:control]}"
	control=beanpool2.tubes[$options[:control]]
	$tubes2put.each do |tubename, expiry|
		if expiry>Time.now
			control.put(tubename)
		end
	end
	puts "done"
end
beanpool2.close

